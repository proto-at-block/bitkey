#include "assert.h"
#include "auth.h"
#include "ipc_impl.h"
#include "log.h"
#include "onboarding.h"
#include "pb_decode.h"
#include "pb_encode.h"
#include "secutils.h"
#include "sleep.h"
#include "wallet.pb.h"

// Autogenerated - do not modify

// clang-format off
SHARED_TASK_DATA ipc_port_obj_t ports[{{num_ports}}] __attribute__((__used__)) = {0};
SHARED_TASK_DATA uint32_t num_ipc_ports = {{num_ports}};


{% for port in ports -%}
const uint32_t {{port}} = {{loop.index - 1}};
{% endfor %}

static bool send_unknown_rsp(void) {
  fwpb_wallet_rsp* rsp = (fwpb_wallet_rsp*)ipc_proto_alloc(sizeof(fwpb_wallet_rsp));
  memset(rsp, 0, sizeof(fwpb_wallet_rsp));

  rsp->status = fwpb_status_UNKNOWN_MESSAGE;
  rsp->unknown_msg = true;

  uint8_t* buffer = ipc_proto_get_response_buffer();
  pb_ostream_t ostream = pb_ostream_from_buffer(buffer, sizeof(fwpb_wallet_rsp));

  pb_encode(&ostream, fwpb_wallet_rsp_fields, rsp);
  ipc_proto_send_response_buffer(buffer, ostream.bytes_written);
  ipc_proto_free((uint8_t*)rsp);

  return true;
}

NO_OPTIMIZE secure_bool_t check_authentication(uint16_t pb_tag) {
  secure_glitch_random_delay();

  // Check if the message does NOT require authentication.
  switch (pb_tag) {
    {% for proto in protos_that_never_require_auth %}
    case fwpb_wallet_cmd_{{'_'.join(proto.split('_')[1:])}}_tag:
    {% endfor %}
      // No auth required, so return SECURE_TRUE here to indicate that
      // the auth status is okay.
      return SECURE_TRUE;
    default:
      break;
  }

  // Check if the message requires authentication only on an onboarded wallet.
  switch (pb_tag) {
    {% for proto in protos_that_require_auth_after_onboarding %}
    case fwpb_wallet_cmd_{{'_'.join(proto.split('_')[1:])}}_tag:
    {% endfor %}
    {
      if (onboarding_complete() != SECURE_TRUE) {
        // Not onboarded. Same as above, return SECURE_TRUE to indicate that
        // authentication is not required.
        return SECURE_TRUE;
      }
      // Onboarded: break out to the auth check.
      break;
    }
    default:
      break;
  }

  // Grant logic follows.
  SECURE_DO_FAILOUT(is_allowing_fingerprint_enrollment() == SECURE_TRUE, {
    switch (pb_tag) {
      case fwpb_wallet_cmd_start_fingerprint_enrollment_cmd_tag:
        return SECURE_TRUE;
      case fwpb_wallet_cmd_delete_fingerprint_cmd_tag:
        return SECURE_TRUE;
      default:
        break;
    }
  });

  // Authentication logic follows.

  fwpb_wallet_rsp* rsp = (fwpb_wallet_rsp*)ipc_proto_alloc(sizeof(fwpb_wallet_rsp));
  memset(rsp, 0, sizeof(fwpb_wallet_rsp));

  rsp->which_msg = pb_tag;
  rsp->status = fwpb_status_UNSPECIFIED;

  volatile secure_bool_t auth_ok = SECURE_FALSE;
  auth_ok = is_authenticated();

  SECURE_DO_FAILIN(auth_ok != SECURE_TRUE, {
    rsp->status = fwpb_status_UNAUTHENTICATED;
    uint8_t* buffer = ipc_proto_get_response_buffer();
    pb_ostream_t ostream = pb_ostream_from_buffer(buffer, sizeof(fwpb_wallet_rsp));

    pb_encode(&ostream, fwpb_wallet_rsp_fields, rsp);
    ipc_proto_send_response_buffer(buffer, ostream.bytes_written);
    ipc_proto_free((uint8_t*)rsp);
    return SECURE_FALSE;
  });

  ipc_proto_free((uint8_t*)rsp);
  return SECURE_TRUE;
}

NO_OPTIMIZE bool ipc_proto_route(uint16_t pb_tag, uint8_t* buffer, uint32_t size) {
  sleep_refresh_power_timer();

  volatile secure_bool_t auth_ok = check_authentication(pb_tag);
  SECURE_IF_FAILIN(auth_ok != SECURE_TRUE) {
    LOGW("Unauthenticated");
    return true;
  };

  refresh_auth();

  switch (pb_tag) {
    {% for port, protos in port_to_proto.items() %}
    {% for proto in protos %}
    case fwpb_wallet_cmd_{{'_'.join(proto.split('_')[1:])}}_tag: {
      return ipc_send({{port}}, buffer, size, IPC_PROTO_{{'_'.join(proto.upper().split('_')[1:])}});
    }
    {% endfor %}

    {% endfor %}
    default:
      LOGE("Got unknown proto with tag %d\n", pb_tag);
      return send_unknown_rsp();
  }
}

  // clang-format on
