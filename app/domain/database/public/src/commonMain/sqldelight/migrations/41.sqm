-- Adds canUseKeyboxKeysets flag to keyboxEntity so the app can know if its
-- locally stored keysets list is complete & authoritative.
-- New column defaults to 0 (false) for existing rows.

ALTER TABLE keyboxEntity ADD COLUMN canUseKeyboxKeysets INTEGER NOT NULL DEFAULT 0;

-- Drop and recreate the fullAccountView to include the new canUseKeyboxKeysets column
DROP VIEW IF EXISTS fullAccountView;

CREATE VIEW fullAccountView AS
SELECT
  fullAccountEntity.accountId AS accountId,
  keyboxEntity.id AS keyboxId,
  keyboxEntity.networkType,
  keyboxEntity.fakeHardware,
  keyboxEntity.f8eEnvironment,
  keyboxEntity.isTestAccount,
  keyboxEntity.isUsingSocRecFakes,
  keyboxEntity.delayNotifyDuration,
  keyboxEntity.appGlobalAuthKeyHwSignature,
  keyboxEntity.canUseKeyboxKeysets,
  spendingKeysetEntity.id AS spendingPublicKeysetId,
  spendingKeysetEntity.serverId AS spendingPublicKeysetServerId,
  spendingKeysetEntity.appKey,
  spendingKeysetEntity.hardwareKey,
  spendingKeysetEntity.serverKey,
  appKeyBundleEntity.id AS appKeyBundleId,
  appKeyBundleEntity.globalAuthKey,
  appKeyBundleEntity.recoveryAuthKey,
  hwKeyBundleEntity.id AS hwKeyBundleId,
  hwKeyBundleEntity.authKey AS hwAuthKey,
  hwKeyBundleEntity.spendingKey AS hwSpendingKey
FROM fullAccountEntity
-- keybox
INNER JOIN keyboxEntity
ON keyboxEntity.accountId = fullAccountEntity.accountId
-- spending public keyset (active one only)
INNER JOIN spendingKeysetEntity
ON spendingKeysetEntity.keyboxId = keyboxEntity.id AND spendingKeysetEntity.isActive = 1
-- app key bundle (active one only)
INNER JOIN appKeyBundleEntity
ON appKeyBundleEntity.keyboxId = keyboxEntity.id AND appKeyBundleEntity.isActive = 1
-- hw key bundle (active one only)
INNER JOIN hwKeyBundleEntity
ON hwKeyBundleEntity.keyboxId = keyboxEntity.id AND hwKeyBundleEntity.isActive = 1;

-- Ensure foreign key constraints remain valid after the schema change
PRAGMA foreign_key_check;
