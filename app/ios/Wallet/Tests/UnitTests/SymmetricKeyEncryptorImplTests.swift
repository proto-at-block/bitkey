import Shared
import XCTest

@testable import Wallet

class SymmetricKeyEncryptorImplTests: XCTestCase {

    func test_sealNoMetadataAndUnsealNoMetadata() throws {
        let keyGenerator = SymmetricKeyGeneratorImpl()
        let encryptor = SymmetricKeyEncryptorImpl()

        let key = keyGenerator.generate()

        let appKey =
            "[b5435236/84'/1'/0']tprv8gw6bXR6ku6tCPZELTH5U5ioSn4k1rkn7Z4P6mWQf5wviG7zM9G6ZN99FXSqhZS77uBMpXzeBVywuA6Rw47k68cUX7N4ody212Ms2JdwFDU/0/*"
        let appKeyByteString = OkioKt.ByteString(data: appKey.data(using: String.Encoding.utf8)!)

        let sealedData = try encryptor.sealNoMetadata(unsealedData: appKeyByteString, key: key)
        let unsealedData = try encryptor.unsealNoMetadata(sealedData: sealedData, key: key)

        XCTAssertEqual(unsealedData, appKeyByteString)
    }

    func test_unsealNoMetadataAndroidCreatedData() throws {
        let encryptor = SymmetricKeyEncryptorImpl()

        let keyRaw = Data(base64Encoded: "tba6tihkCGK0Ks9fM5qmc6FBUNFDedNDut57GYBS83k=")!
        let ciphertext = Data(base64Encoded: "vwaoULHHAk6zUjWohw==")!
        let nonce = Data(base64Encoded: "d7GeMirUxwPB54H4Og8e5kVomWHaiSyK")!
        let tag = Data(base64Encoded: "eSKF6Q5/VjMA9WNvudqBAg==")!
        let sealedData = SealedData(
            ciphertext: OkioKt.ByteString(data: ciphertext),
            nonce: OkioKt.ByteString(data: nonce),
            tag: OkioKt.ByteString(data: tag)
        )
        let key = SymmetricKeyImpl(raw: OkioKt.ByteString(data: keyRaw))

        let unsealedData = try encryptor.unsealNoMetadata(sealedData: sealedData, key: key)

        let expected = OkioKt.ByteString(data: "13 characters".data(using: .utf8)!)
        XCTAssertEqual(expected, unsealedData)
    }

    func test_unsealAndroidCreatedXCiphertext() throws {
        let encryptor = SymmetricKeyEncryptorImpl()

        let keyRaw = OkioByteString.Companion.shared
            .decodeHex("a01584980e6adfa1fc5671e0b35642964802e2ea83f65d0178b20e83c986520a")
        let key = SymmetricKeyImpl(raw: keyRaw)
        let aad = OkioKt.ByteString(data: "cross-platform-aad".data(using: .utf8)!)
        let expectedData = OkioKt.ByteString(data: "test cross platform data".data(using: .utf8)!)

        // This XCiphertext was generated by Android using the same key, data, and AAD
        let androidGeneratedXCiphertext =
            XCiphertext(
                value: "eyJhbGciOiJYQ2hhQ2hhMjBQb2x5MTMwNSJ9.9wQ03W6YnC5EXvhO3sNPh08DjmRzl1xDBA0DTGFBZ6mfgFIfAFE6Lw.EzcowT5VjKMjQQVvg+xnsmNQCSnfOYlS"
            )

        // Test that iOS can decrypt Android-generated XCiphertext
        let decrypted = try encryptor.unseal(
            ciphertext: androidGeneratedXCiphertext,
            key: key,
            aad: aad
        )
        XCTAssertEqual(decrypted, expectedData)
    }

    func test_sealAndUnseal() throws {
        let keyGenerator = SymmetricKeyGeneratorImpl()
        let encryptor = SymmetricKeyEncryptorImpl()

        let key = keyGenerator.generate()

        let appKey =
            "[b5435236/84'/1'/0']tprv8gw6bXR6ku6tCPZELTH5U5ioSn4k1rkn7Z4P6mWQf5wviG7zM9G6ZN99FXSqhZS77uBMpXzeBVywuA6Rw47k68cUX7N4ody212Ms2JdwFDU/0/*"
        let appKeyByteString = OkioKt.ByteString(data: appKey.data(using: String.Encoding.utf8)!)
        let aad = OkioKt.ByteString(data: "aad".data(using: .utf8)!)

        let ciphertext = try encryptor.seal(unsealedData: appKeyByteString, key: key, aad: aad)
        let unsealedData = try encryptor.unseal(ciphertext: ciphertext, key: key, aad: aad)

        XCTAssertEqual(unsealedData, appKeyByteString)
    }

    func test_unsealWithWrongAadShouldFail() throws {
        let keyGenerator = SymmetricKeyGeneratorImpl()
        let encryptor = SymmetricKeyEncryptorImpl()

        let key = keyGenerator.generate()
        let data = OkioKt.ByteString(data: "Test data".data(using: .utf8)!)
        let correctAad = OkioKt.ByteString(data: "correct aad".data(using: .utf8)!)
        let wrongAad = OkioKt.ByteString(data: "wrong aad".data(using: .utf8)!)

        let ciphertext = try encryptor.seal(unsealedData: data, key: key, aad: correctAad)

        // Should throw when trying to unseal with wrong AAD
        XCTAssertThrowsError(try encryptor.unseal(ciphertext: ciphertext, key: key, aad: wrongAad))
    }

}
