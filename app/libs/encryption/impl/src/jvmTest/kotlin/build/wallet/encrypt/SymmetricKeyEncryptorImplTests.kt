package build.wallet.encrypt

import build.wallet.crypto.SymmetricKeyImpl
import build.wallet.rust.core.ChaCha20Poly1305Exception
import io.kotest.assertions.throwables.shouldThrow
import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.equals.shouldBeEqual
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import okio.ByteString.Companion.decodeHex
import okio.ByteString.Companion.encodeUtf8
import okio.ByteString.Companion.toByteString

class SymmetricKeyEncryptorImplTests : FunSpec({

  val symmetricKeyEncryptor = SymmetricKeyEncryptorImpl()
  val symmetricKeyGenerator = SymmetricKeyGeneratorImpl()

  test("sealNoMetadata and unsealNoMetadata should return original data") {
    val key = symmetricKeyGenerator.generate()

    val originalData = "13 characters".encodeUtf8()
    val sealedData = symmetricKeyEncryptor.sealNoMetadata(originalData, key)
    val unsealedData = symmetricKeyEncryptor.unsealNoMetadata(sealedData, key)
    unsealedData shouldBe originalData
  }

  test("sealing the same data with different nonces should produce different ciphertexts") {
    val key = symmetricKeyGenerator.generate()
    val data = "Repeatable test data".encodeUtf8()

    // Seal the data twice, with different nonces each time
    val sealedData1 = symmetricKeyEncryptor.sealNoMetadata(data, key)
    val sealedData2 = symmetricKeyEncryptor.sealNoMetadata(data, key)

    // The sealed (ciphertext) data should not be the same, due to different nonces
    sealedData1.ciphertext shouldNotBe sealedData2.ciphertext
  }

  test("sealed data from iOS should unseal on Android") {
    val key = "a01584980e6adfa1fc5671e0b35642964802e2ea83f65d0178b20e83c986520a".decodeHex()
    val sealed = SealedData(
      ciphertext = "9774e28e333ef24390d8d68d9d0b90ef56ced0dc531b5ee560abcc109eeb3d275812dad82e834c0fceea8ec9d3d1a34008ef505e103a7724d18aaab768b857efedafbd4e74a02ab6993a995a1bf321c8b2c825762f8dbd4d062be99114651f2e7f2f8439f5fe1585a2efde854ff26f268c9420e23500a9fd650c823edf22b250585f8ff95c8e8d".decodeHex(),
      nonce = "c7335a4a2cb943e7ff3c4a3d87a016e5d977e803c7989d9c".decodeHex(),
      tag = "e2b61dabf0857c5e71bc5231be5a8578".decodeHex()
    )
    symmetricKeyEncryptor.unsealNoMetadata(sealed, SymmetricKeyImpl(raw = key))
      .shouldBeEqual(
        "[b5435236/84'/1'/0']tprv8gw6bXR6ku6tCPZELTH5U5ioSn4k1rkn7Z4P6mWQf5wviG7zM9G6ZN99FXSqhZS77uBMpXzeBVywuA6Rw47k68cUX7N4ody212Ms2JdwFDU/0/*"
          .toByteArray()
          .toByteString()
      )
  }

  test("XCiphertext from iOS should unseal on Android") {
    val key = SymmetricKeyImpl(raw = "a01584980e6adfa1fc5671e0b35642964802e2ea83f65d0178b20e83c986520a".decodeHex())
    val aad = "cross-platform-aad".encodeUtf8()
    val expectedData = "test cross platform data".encodeUtf8()

    // This XCiphertext was generated by iOS using the same key, data, and AAD
    val iosGeneratedXCiphertext = XCiphertext("eyJhbGciOiJYQ2hhQ2hhMjBQb2x5MTMwNSJ9.hCCLMvBXcLUgVml/lfy3h/8C+PXPfqHO0yHy3C/9U6vVlQ58TIlegg.o1uFH1M9OQipLUYDMIyc0TKVlTA4JJGd")

    // Test that Android can decrypt iOS-generated XCiphertext
    val decrypted = symmetricKeyEncryptor.unseal(iosGeneratedXCiphertext, key, aad)
    decrypted shouldBe expectedData
  }

  test("seal with aad and unseal should return original data") {
    val key = symmetricKeyGenerator.generate()
    val originalData = "Test data with AAD".encodeUtf8()
    val aad = "additional authenticated data".encodeUtf8()

    val ciphertext = symmetricKeyEncryptor.seal(originalData, key, aad)
    val unsealedData = symmetricKeyEncryptor.unseal(ciphertext, key, aad)

    unsealedData shouldBe originalData
  }

  test("unseal with wrong aad should fail") {
    val key = symmetricKeyGenerator.generate()
    val data = "Test data".encodeUtf8()
    val correctAad = "correct aad".encodeUtf8()
    val wrongAad = "wrong aad".encodeUtf8()

    val ciphertext = symmetricKeyEncryptor.seal(data, key, correctAad)

    // Should throw when trying to unseal with wrong AAD
    shouldThrow<ChaCha20Poly1305Exception.DecryptException> {
      symmetricKeyEncryptor.unseal(ciphertext, key, wrongAad)
    }
  }
})
