---
description: Guidelines for using and implementing F8e API client classes
globs: ["**/*.kt"]
alwaysApply: true
---

# F8e Client Implementation

## Summary
F8e (Fromagerie) clients provide type-safe network communication with consistent error handling, authentication, and logging.

## When to Apply
- Creating/modifying F8e client interfaces or implementations
- Adding mock implementations for testing

## How to Apply

### Structure & Naming
- **Modules**: `:domain:f8e-client:public/impl/fake`
- **Packages**: `bitkey.f8e.*` (new), `build.wallet` (legacy only)
- **Naming**: `[Domain][Action]F8eClient` (single-call), `[Domain]F8eClient` (multi-call)

### Method Requirements
Every method must:
- Be `suspend` function
- Return `Result<T, NetworkingError>` or `Result<T, F8eError<ErrorCodeType>>`
- Use `setRedactedBody()` by default (only `setUnredactedBody()` for safe data)
- Include `withEnvironment(f8eEnvironment)`
- Include `withAccountId(accountId, tokenScope)` for authenticated requests

### Implementation Patterns
**Unauthenticated:**
```kotlin
override suspend fun someCall(request: SomeRequest): Result<SomeResponse, NetworkingError> =
  f8eHttpClient.unauthenticated()
    .bodyResult<SomeResponseBody> {
      post("/api/endpoint") {
        withEnvironment(f8eEnvironment)
        setRedactedBody(SomeRequestBody(field = request.field))
      }
    }.map { it.toSomeResponse() }
```

**Authenticated:**
```kotlin
override suspend fun someCall(
  f8eEnvironment: F8eEnvironment,
  accountId: AccountId,
  request: SomeRequest
): Result<SomeResponse, NetworkingError> =
  f8eHttpClient.authenticated()
    .bodyResult<SomeResponseBody> {
      post("/api/endpoint") {
        withEnvironment(f8eEnvironment)
        withAccountId(accountId, AuthTokenScope.Recovery)
        setRedactedBody(SomeRequestBody(field = request.field))
      }
    }.map { it.toSomeResponse() }
```

### Bodies & Error Handling
- Request/response bodies implement `RedactedRequestBody`/`RedactedResponseBody`
- Use `@SerialName` for JSON mapping
- Use `mapError { it.toF8eError<ErrorCodeType>() }` for F8e errors
- Prefer typed error codes when available

### DI & Constraints
```kotlin
@BitkeyInject(AppScope::class)
class SomeF8eClientImpl(
  private val f8eHttpClient: F8eHttpClient,
) : SomeF8eClient
```

**Must be**: Stateless, side-effect-free, no unit tests (use mocks in `:fake`)

### Anti-Patterns
```kotlin
// ‚ùå BAD: Unredacted bodies, missing environment, stateful clients
setUnredactedBody(requestBody) // Security risk
post("/api/endpoint") { /* missing withEnvironment */ }
class BadClient {
  private var cached: String? = null // Don't store state
}
```

### Mock Pattern
```kotlin
class SomeF8eClientMock(
  var defaultResult: Result<SomeResponse, NetworkingError> = 
    Err(UnhandledException(NotImplementedError()))
) : SomeF8eClient {
  
  override suspend fun someCall(request: SomeRequest) = defaultResult
  
  fun reset() {
    defaultResult = Err(UnhandledException(NotImplementedError()))
  }
}
```

## Example
```kotlin
// Interface
interface AuthF8eClient {
  suspend fun authenticate(
    f8eEnvironment: F8eEnvironment,
    request: AuthRequest
  ): Result<AuthResponse, F8eError<AuthF8eClientErrorCode>>
}

// Implementation
@BitkeyInject(AppScope::class)
class AuthF8eClientImpl(
  private val f8eHttpClient: F8eHttpClient,
) : AuthF8eClient {
  
  override suspend fun authenticate(
    f8eEnvironment: F8eEnvironment,
    request: AuthRequest
  ): Result<AuthResponse, F8eError<AuthF8eClientErrorCode>> =
    f8eHttpClient.unauthenticated()
      .bodyResult<AuthResponseBody> {
        post("/api/authenticate") {
          withEnvironment(f8eEnvironment)
          setRedactedBody(AuthRequestBody(challenge = request.challenge))
        }
      }
      .mapError { it.toF8eError<AuthF8eClientErrorCode>() }
      .map { it.toAuthResponse() }
}
```

## Related Rules
- @ai-rules/strong-typing.mdc (domain types and Result usage)