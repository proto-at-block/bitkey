---
description: UI State Machine model types, FormBodyModel patterns, presentation styles, and immutable collections
globs: ["**/*StateMachine*.kt", "**/*UiStateMachine*.kt", "**/*Model*.kt"]
alwaysApply: true
---

# UI State Machine Models

## Summary

Immutable data classes representing UI presentation state. Models contain only raw, displayable data with simple callbacks. State Machines handle data processing, type conversion, and business logic delegation.

## Model Hierarchy

**Types:**
- `Model` - Base interface with stable `key`
- `ComposeModel` - Has `@Composable render()` method
- `BodyModel` - Screen content with analytics
- `ScreenModel` - Body + overlays + presentation style

**Examples:**
```kotlin
// BodyModel for general screens
class SettingsBodyModel(...) : BodyModel() {
  override val eventTrackerScreenInfo = EventTrackerScreenInfo(SETTINGS_SCREEN)
}

// FormBodyModel for structured forms
class EditProfileFormBodyModel(...) : FormBodyModel(
  id = EDIT_PROFILE_SCREEN,
  toolbar = ToolbarModel(title = "Edit Profile"),
  mainContentList = listOf(nameField, emailField),
  primaryButton = ButtonModel("Save", onSave)
)

// ScreenModel with overlays
ScreenModel(
  body = bodyModel,
  presentationStyle = ScreenPresentationStyle.Root,
  alertModel = confirmationAlert,
  bottomSheetModel = actionSheet
)
```

## Model Selection Priority

**1. Common Models (HIGHEST PREFERENCE):**
Use pre-built models from `:ui:features:public`:
- `LoadingBodyModel` - Loading screen with message/back button
- `ErrorFormBodyModel` - Error screen with retry/back actions
- `SuccessBodyModel` - Confirmation screens
- `FormBodyModel` - Structured forms (settings, lists, input forms)

**2. Custom FormBodyModel (SECOND PREFERENCE):**
```kotlin
data class KeysetListFormBodyModel(
  val keysetItems: List<String>, // Raw displayable data
  val activeStatuses: List<String>, // Pre-processed strings
  val onKeysetSelected: (String) -> Unit,
  val onBack: () -> Unit
) : FormBodyModel(
  id = KEYSET_LIST_SCREEN,
  toolbar = ToolbarModel(title = "Keysets"),
  mainContentList = keysetItems.mapIndexed { index, keysetId ->
    ListItemModel(
      leadingAccessory = keysetId,
      trailingAccessory = activeStatuses[index],
      onClick = { onKeysetSelected(keysetId) }
    )
  }
)
```

**3. ComposeModel (LAST RESORT):**
```kotlin
// Only when FormBodyModel insufficient
data class CustomVisualizationBodyModel(
  val chartData: List<Float>, // Raw values only
  val labelText: String, // Pre-processed text
  val onDataPointSelected: (Int) -> Unit
) : ComposeModel {
  @Composable
  override fun render(modifier: Modifier) {
    CustomChartVisualization(
      modifier = modifier, // Always use modifier
      data = chartData,
      label = labelText,
      onSelection = onDataPointSelected
    )
  }
}
```

## Avoid Generic Models

**❌ BAD: Conditional rendering**
```kotlin
data class GenericFormBodyModel(
  val isLoading: Boolean,
  val error: String?,
  val data: Data?
) : FormBodyModel(
  mainContentList = when {
    isLoading -> listOf(LoadingComponent)
    error != null -> listOf(ErrorComponent(error))
    else -> listOf(DataComponent(data))
  }
)
```

**✅ GOOD: Separate models per state**
```kotlin
data class LoadingFormBodyModel(val message: String = "Loading...") : FormBodyModel(...)
data class ErrorFormBodyModel(val error: String, val onRetry: () -> Unit) : FormBodyModel(...)
data class DataFormBodyModel(val data: Data, val onSubmit: () -> Unit) : FormBodyModel(...)
```

**Principles:** One model per UI state, use Type 2 State Machines for orchestration.

## Model Design Guidelines

**Rules:**
- **Immutable `data class`** - never `sealed class/interface`
- **Raw, displayable values** - `String` not `SpendingKeyset`
- **State Machines handle conversion** - strong types → raw display values
- **Simple fields/callbacks** - `() -> Unit` or `(SimpleType) -> Unit`
- **Immutable collections** - `kotlinx.collections.immutable` types

## Immutable Collections

**Always use for Compose stability:**

```kotlin
import kotlinx.collections.immutable.*

// ✅ GOOD: Immutable collections
data class TransactionListFormBodyModel(
  val transactions: ImmutableList<String>, // Stable for Compose
  val selectedIds: ImmutableSet<String>,
  val onTransactionSelected: (String) -> Unit
) : FormBodyModel(...)

// ❌ BAD: Mutable collections cause recomposition issues
data class BadModel(
  val transactions: List<String>, // Unstable
  val selectedIds: Set<String> // Unstable
)
```

**Convert in State Machine:**
```kotlin
@Composable
override fun model(props: TransactionProps): ScreenModel {
  val transactions by remember { transactionService.transactions }.collectAsState()
  
  val transactionDisplayList = transactions
    .map { it.formattedDescription }
    .toImmutableList()
  
  val selectedIds = props.selectedIds.toImmutableSet()
  
  return TransactionListFormBodyModel(
    transactions = transactionDisplayList,
    selectedIds = selectedIds
  ).asRootScreen()
}
```

**Use `ImmutableList` for ordered, `ImmutableSet` for unique collections. Convert at State Machine level.**

## Prohibited Patterns

```kotlin
// ❌ BAD: Complex objects and dependencies
data class BadModel(
  val keyset: SpendingKeyset, // Don't pass domain objects
  val clock: Clock, // Never dependencies/components
  val onAction: suspend () -> Unit // No suspend callbacks
)

// ❌ BAD: Logic in models
data class BadLogicModel(
  val keysetId: String
) {
  val formattedKeysetId: String get() = keysetId.chunked(4).joinToString("-") // No
}

// ✅ GOOD: Raw, simple data
data class GoodModel(
  val displayText: String, // Pre-processed
  val isEnabled: Boolean,
  val onTap: () -> Unit
)
```

**Naming:** Use `FeatureActionFormBodyModel` pattern, avoid generic names, match business terminology.

## Helper Functions

**Only for substantial reused logic:**
```kotlin
// ✅ GOOD: Complex shared logic
private fun transactionListFormModel(
  transactions: List<Transaction>,
  isLoading: Boolean,
  onTransactionSelected: (String) -> Unit,
  onBack: () -> Unit
): FormBodyModel {
  val contentList = buildList {
    if (isLoading) add(LoadingItemModel())
    else addAll(transactions.map { 
      ListItemModel(title = it.formattedAmount, onClick = { onTransactionSelected(it.id) })
    })
  }
  return FormBodyModel(id = TRANSACTION_LIST_SCREEN, mainContentList = contentList)
}

// ❌ BAD: Unnecessary function
private fun errorFormModel(errorText: String) = ErrorFormBodyModel(title = "Error", subline = errorText)
```

**ComposeModel Constraints:** UI logic only, no business logic/dependencies, accept `modifier`, raw data only.

## Model Conversion

**State Machine handles all conversion:**
```kotlin
@Composable
override fun model(props: KeysetProps): ScreenModel {
  val keysets by remember { keysetService.keysets }.collectAsState()
  
  // Format data here, not in model
  val keysetDisplayItems = keysets.map { 
    it.id.serverId.stringValue.chunked(4).joinToString("-")
  }
  val statusDisplayItems = keysets.map { 
    if (it.isActive) "Active" else "Inactive"
  }
  
  return KeysetListFormBodyModel(
    keysetItems = keysetDisplayItems, // Pre-formatted
    activeStatuses = statusDisplayItems, // Pre-processed
    onKeysetSelected = { /* handle */ },
    onBack = props.onBack
  ).asRootScreen()
}
```

## Presentation Styles

**Choose based on context:**

- **`asRootScreen()`** - Primary navigation destinations
- **`asModalScreen()`** - Secondary flows over context
- **`asSheetModalScreen()`** - Contextual actions/forms
- **`asModalFullScreen()`** - Immersive critical flows

```kotlin
HomeBodyModel(...).asRootScreen(statusBannerModel = networkStatus)
TransactionDetailsBodyModel(...).asModalScreen(alertModel = dialog)
ContactFormBodyModel(...).asSheetModalScreen(onClosed = { })
OnboardingBodyModel(...).asModalFullScreen()
```

## Overlay Management

**Use nullable state at ScreenModel level:**

```kotlin
@Composable
override fun model(props: SettingsProps): ScreenModel {
  var alertModel by remember { mutableStateOf<AlertModel?>(null) }
  var bottomSheet by remember { mutableStateOf<SheetModel?>(null) }
  
  val bodyModel = SettingsBodyModel(
    onDeleteAccount = {
      alertModel = ButtonAlertModel(
        title = "Delete Account",
        onPrimaryButtonClick = { /* confirm */ },
        onSecondaryButtonClick = { alertModel = null }
      )
    },
    onShowHelp = {
      bottomSheet = SheetModel(
        body = HelpBodyModel(...),
        onClosed = { bottomSheet = null }
      )
    }
  )
  
  return bodyModel.asRootScreen(
    alertModel = alertModel,
    bottomSheetModel = bottomSheet
  )
}
```

**Types:** `AlertModel`, `SheetModel`, `ToastModel`, `StatusBannerModel`.

## Conditional Rendering

**Nullable state for overlays:**
```kotlin
var bottomSheet by remember { mutableStateOf<SheetModel?>(null) }
val bodyModel = HomeBodyModel(
  onShowActions = {
    bottomSheet = SheetModel(body = ActionSheetBodyModel(...))
  }
)
return bodyModel.asRootScreen(bottomSheetModel = bottomSheet)
```

**Return null for features:**
```kotlin
@Composable
override fun model(props: FeatureCardProps): CardModel? {
  val enabled by remember { featureFlag.isEnabled }.collectAsState()
  if (!enabled) return null
  return FeatureCardModel(...)
}
```

**Patterns:** Nullable state for overlays, `takeIf {}` for optional elements, `return null` for features, early returns.

## Guidelines

**Usage:** Start with common models, reference `:ui:features:public` for definitions, check existing implementations.

**Architecture:**
- **Immutable data flow** - models are immutable, state flows unidirectionally
- **Callback events** - use callbacks not Navigator injection
- **Composable** - State Machines compose hierarchically, clear business/presentation separation

## Related Rules

- @ai-rules/ui-state-machines-basics.mdc (core concepts)
- @ai-rules/ui-state-machines-patterns.mdc (advanced techniques)
- @ai-rules/strong-typing.mdc (type safety)
- @ai-rules/module-structure.mdc (placement)