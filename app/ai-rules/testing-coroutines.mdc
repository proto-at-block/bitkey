---
description: Testing coroutines, flows, and async operations
globs: ["**/*Tests.kt", "**/src/commonTest/**"]
alwaysApply: true
---

# Coroutine and Async Testing

## Summary

Testing coroutines, Flows, and async operations. Use Turbine `.test {}` for Flow testing, direct `.awaitItem()` for mock verification.

## When to Apply

- Testing suspend functions
- Testing Flow emissions
- Verifying async operation timing
- Testing error propagation in async contexts

## How to Apply

### Flow Testing with Turbine

**Use `.test {}` for Flow testing:**
```kotlin
test("emits account status changes") {
  val dao = AccountDaoFake()
  val service = AccountServiceImpl(dao)
  
  service.accountStatus().test {
    // Initial state
    awaitItem().shouldBeOk(NoAccount)
    
    // Trigger change
    dao.setActiveAccount(FullAccountMock)
    
    // Verify emission
    awaitItem().shouldBeOk(ActiveAccount(FullAccountMock))
  }
}
```

**Critical: Different patterns for different uses:**
```kotlin
// ✅ For Flow testing - use .test {}
flowUnderTest.test {
  awaitItem().shouldBe(expected)
}

// ✅ For Mock verification - use direct awaitItem()
mockService.methodCalls.awaitItem().shouldBe(expected)

// ❌ NEVER use .test {} for mock verification
mockService.methodCalls.test { awaitItem() }  // WRONG
```

### Suspend Function Testing

```kotlin
test("performs async operation") {
  val service = AsyncServiceImpl()
  
  // Call suspend functions directly
  val result = service.processAsync(request)
  
  result.shouldBeOk(expectedValue)
}

test("handles async failure") {
  val client = F8eClientFake()
  client.setNetworkError(true)
  
  val result = service.performOperation()
  
  result.shouldBeErr()
  result.error.shouldBeTypeOf<NetworkError>()
}
```

### Turbine Best Practices

**Avoid non-deterministic methods:**
```kotlin
// ❌ BAD - Non-deterministic
expectNoEvents()
expectMostRecentItem()

// ✅ OK - Deterministic but adds delay (use sparingly)
awaitNoEvents(50.milliseconds)  // Default delay

// ✅ GOOD - Explicit verification
awaitItem().shouldBe(expected)
awaitComplete()
awaitError().shouldBeTypeOf<ExpectedError>()

// ✅ GOOD - Skip to specific item
awaitUntil { it.status == Status.Ready }
awaitUntil<SpecificType>()  // Skip until type matches
```

### Testing Concurrent Operations

```kotlin
test("handles concurrent requests") {
  val service = ConcurrentService()
  
  val results = (1..10).map { 
    async { service.performOperation(it) }
  }.awaitAll()
  
  results.forEach { it.shouldBeOk() }
}
```

### Mock Behavior in Async Context

```kotlin
class EventTrackerMock(
  turbine: (String) -> Turbine<Any>
) : EventTracker {
  var trackResult: Result<Unit, Error> = Ok(Unit)
  
  // Use val for deterministic tracking
  val trackEventCalls = turbine("trackEvent")
  
  override suspend fun trackEvent(event: Event): Result<Unit, Error> {
    trackEventCalls += event
    return trackResult
  }
}

// Usage - define at spec level
class MobilePayServiceTests : FunSpec({
  // Turbines defined at spec level - auto cleanup
  val tracker = EventTrackerMock(turbines::create)
  val service = MobilePayService(tracker)
  
  test("tracks mobile pay enabled event") {
    service.enableMobilePay(limit)
    
    // Direct awaitItem for mock verification
    tracker.trackEventCalls
      .awaitItem()
      .shouldBeTypeOf<Event.MobilePayEnabled>()
  }
})
```

## Example

```kotlin
class AuthTokensServiceImplTests : FunSpec({
  // All test doubles defined at spec level
  val tokenDao = AuthTokenDaoFake()
  val f8eClient = AuthF8eClientFake()
  val eventTracker = EventTrackerMock(turbines::create)
  
  val service = AuthTokensServiceImpl(
    dao = tokenDao,
    client = f8eClient,
    tracker = eventTracker
  )
  
  beforeTest {
    tokenDao.reset()
    f8eClient.reset()
    // Note: turbines auto-reset, no manual reset needed
  }
  
  test("refreshes tokens and emits update") {
    val oldTokens = AuthTokens("old-access", "old-refresh")
    val newTokens = AuthTokens("new-access", "new-refresh")
    
    tokenDao.setTokens(oldTokens)
    f8eClient.setRefreshResponse(newTokens)
    
    // Test Flow emissions
    service.tokensFlow().test {
      awaitItem().shouldBeOk(oldTokens)
      
      service.refreshTokens()
      
      awaitItem().shouldBeOk(newTokens)
    }
    
    // Verify tracking (mock)
    eventTracker.trackEventCalls
      .awaitItem()
      .shouldBeTypeOf<Event.TokensRefreshed>()
  }
  
  test("handles refresh failure") {
    f8eClient.setRefreshError(NetworkError.Unauthorized)
    
    val result = service.refreshTokens()
    
    result.shouldBeErr()
    result.error.shouldBeTypeOf<AuthError.RefreshFailed>()
  }
})
```

## Related Rules

- @ai-rules/testing-basics.mdc (core patterns)
- @ai-rules/testing-fakes-mocks.mdc (mock setup)
- @ai-rules/testing-services.mdc (service async testing)