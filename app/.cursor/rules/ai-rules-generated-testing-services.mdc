---
description: Testing domain services and business logic
alwaysApply: true
---

# Service Testing

## Summary

Testing domain services that orchestrate business logic. Test business rules, workflows, and dependency coordination using fakes.

## When to Apply

- Testing domain service implementations
- Verifying business rule enforcement  
- Testing service orchestration/workflows
- Validating error handling and recovery

## How to Apply

### Basic Structure

```kotlin
class MobilePayServiceImplTests : FunSpec({
  val spendingLimitDao = SpendingLimitDaoFake()
  val f8eClient = MobilePayF8eClientFake()
  val bitcoinWalletService = BitcoinWalletServiceFake()
  val eventTracker = EventTrackerMock(turbines::create)
  
  val service = MobilePayServiceImpl(
    dao = spendingLimitDao,
    f8eClient = f8eClient,
    walletService = bitcoinWalletService,
    eventTracker = eventTracker
  )
  
  beforeTest {
    spendingLimitDao.reset()
    f8eClient.reset()
    bitcoinWalletService.reset()
  }
})
```

### Testing Business Operations

```kotlin
test("enables mobile pay when wallet has sufficient balance") {
  bitcoinWalletService.setBalance(BitcoinMoney.btc(1.0))
  val limit = SpendingLimit(BitcoinMoney.btc(0.1), SpendingPeriod.Daily)
  
  val result = service.enableMobilePay(limit)
  
  result.shouldBeOk()
  spendingLimitDao.getActiveLimit().shouldBeOk(limit)
  f8eClient.getLastSyncedLimit().shouldBe(limit)
  
  eventTracker.trackEventCalls
    .awaitItem()
    .shouldBeTypeOf<Event.MobilePayEnabled>()
}

test("returns error when balance insufficient") {
  bitcoinWalletService.setBalance(BitcoinMoney.btc(0.05))
  val limit = SpendingLimit(BitcoinMoney.btc(0.1), SpendingPeriod.Daily)
  
  val result = service.enableMobilePay(limit)
  
  result.shouldBeErr()
  result.error.shouldBeTypeOf<MobilePayError.InsufficientBalance>()
  spendingLimitDao.getActiveLimit().shouldBeOk(null)
}
```

### Testing Workflows

```kotlin
test("syncs spending limit with server periodically") {
  spendingLimitDao.setActiveLimit(SpendingLimitMock)
  
  service.syncStatus().test {
    awaitItem().shouldBe(SyncStatus.Syncing)
    awaitItem().shouldBe(SyncStatus.Synced)
    
    service.triggerSync()
    
    awaitItem().shouldBe(SyncStatus.Syncing)
    awaitItem().shouldBe(SyncStatus.Synced)
  }
  
  f8eClient.getSyncCount().shouldBe(2)
}
```

### Testing Error Recovery

```kotlin
test("retries on transient network errors") {
  f8eClient.setNextError(NetworkError.Timeout)
  service.syncWithServer().shouldBeErr()
  
  f8eClient.clearError()
  service.syncWithServer().shouldBeOk()
}

test("handles permanent errors without retry") {
  f8eClient.setNextError(HttpError.Unauthorized)
  
  val result = service.syncWithServer()
  
  result.shouldBeErr()
  result.error.shouldBeTypeOf<MobilePayError.AuthenticationRequired>()
  f8eClient.getRequestCount().shouldBe(1)
}
```

### Testing Concurrent Operations

```kotlin
test("handles concurrent limit updates safely") {
  val limits = (1..10).map { SpendingLimit(BitcoinMoney.btc(it * 0.01), SpendingPeriod.Daily) }
  
  val results = limits.map { limit ->
    async { service.updateLimit(limit) }
  }.awaitAll()
  
  results.forEach { it.shouldBeOk() }
  
  val activeLimit = spendingLimitDao.getActiveLimit()
  activeLimit.shouldBeOk()
  limits.shouldContain(activeLimit.value)
}
```

### Testing Business Rules

```kotlin
test("enforces daily spending limit across multiple transactions") {
  val dailyLimit = SpendingLimit(BitcoinMoney.btc(0.1), SpendingPeriod.Daily)
  service.enableMobilePay(dailyLimit)
  
  service.createTransaction(BitcoinMoney.btc(0.05)).shouldBeOk()
  service.createTransaction(BitcoinMoney.btc(0.04)).shouldBeOk()
  
  val tx3 = service.createTransaction(BitcoinMoney.btc(0.02))
  tx3.shouldBeErr()
  tx3.error.shouldBeTypeOf<MobilePayError.DailyLimitExceeded>()
  
  service.getRemainingDailyLimit().shouldBeOk(BitcoinMoney.btc(0.01))
}
```

## Example

```kotlin
class RecoveryServiceImplTests : FunSpec({
  val recoveryDao = RecoveryDaoFake()
  val f8eClient = RecoveryF8eClientFake()
  val hardwareService = HardwareServiceFake()
  val eventTracker = EventTrackerMock(turbines::create)
  
  val service = RecoveryServiceImpl(
    dao = recoveryDao,
    f8eClient = f8eClient,
    hardware = hardwareService,
    tracker = eventTracker
  )
  
  beforeTest {
    recoveryDao.reset()
    f8eClient.reset()
    hardwareService.reset()
  }
  
  test("initiates recovery when hardware is lost") {
    recoveryDao.setAccount(FullAccountMock)
    
    val result = service.initiateRecovery(RecoveryType.LostHardware, FullAccountMock.accountId)
    
    result.shouldBeOk()
    val recovery = result.value
    recovery.type.shouldBe(RecoveryType.LostHardware)
    recovery.status.shouldBe(RecoveryStatus.AwaitingVerification)
    
    f8eClient.getActiveRecovery().shouldBe(recovery)
    
    eventTracker.trackEventCalls
      .awaitItem()
      .shouldBeTypeOf<Event.RecoveryInitiated>()
  }
  
  test("completes recovery after verification") {
    recoveryDao.setActiveRecovery(RecoveryMock)
    hardwareService.setVerificationResult(true)
    
    val result = service.completeRecovery(RecoveryMock.id)
    
    result.shouldBeOk()
    recoveryDao.getActiveRecovery().shouldBeOk(null)
    f8eClient.getCompletedRecoveries().shouldContain(RecoveryMock.id)
  }
})
```

## Key Patterns

- **Business Logic Focus:** Test what the service does, not how
- **State Verification:** Use fakes to verify state changes  
- **Error Path Coverage:** Test all error conditions
- **Workflow Testing:** Verify multi-step operations

## Related Rules

- @ai-rules/domain-service-pattern.md (service architecture)
- @ai-rules/testing-basics.md (core patterns)  
- @ai-rules/testing-fakes-mocks.md (test doubles)
- @ai-rules/testing-coroutines.md (async testing)
