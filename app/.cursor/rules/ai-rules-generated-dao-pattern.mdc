---
description: DAO pattern implementation for data persistence with SQLDelight
alwaysApply: true
---

# DAO Pattern Implementation

## Summary

DAO (Data Access Object) pattern for SQLDelight database operations. Provides data persistence abstraction consumed by Services.

## When to Apply

- Creating data persistence components
- Implementing database access for domain entities  
- Building data access layers for services
- Integrating with BitkeyDatabaseProvider

## How to Apply

### Structure

**Placement:**
- Interface/Implementation: `:impl` modules only (NOT in `:public`)
- Fakes: `:fake` modules
- Consumers: Service classes

### Core Patterns

- **Result Types:** `Result<T, Error>` for all methods
- **Suspend Functions:** All database operations
- **DI:** `@BitkeyInject(AppScope::class)`
- **SQLDelight Extensions:**
  - `awaitTransactionWithResult()` - writes
  - `awaitAsOneOrNullResult()` - single queries  
  - `awaitAsListResult()` - list queries

### Templates

**Interface:**
```kotlin
interface EntityDao {
  suspend fun insertEntity(entity: Entity): Result<Unit, Error>
  suspend fun getEntity(id: EntityId): Result<Entity?, Error>
  suspend fun getAllEntities(): Result<List<Entity>, Error>
}
```

**Implementation:**
```kotlin
@BitkeyInject(AppScope::class)
class EntityDaoImpl(
  private val databaseProvider: BitkeyDatabaseProvider,
) : EntityDao {
  
  override suspend fun insertEntity(entity: Entity): Result<Unit, DbError> =
    databaseProvider.database()
      .entityQueries
      .awaitTransactionWithResult {
        insertEntity(id = entity.id, name = entity.name)
      }
  
  override suspend fun getEntity(id: EntityId): Result<Entity?, DbError> =
    databaseProvider.database()
      .entityQueries
      .getEntity(id)
      .awaitAsOneOrNullResult()
      .map { it?.toEntity() }
}
```

**Fake:**
```kotlin
class EntityDaoFake : EntityDao {
  private val entities = mutableMapOf<EntityId, Entity>()
  
  override suspend fun insertEntity(entity: Entity): Result<Unit, Error> {
    entities[entity.id] = entity
    return Ok(Unit)
  }
  
  override suspend fun getEntity(id: EntityId): Result<Entity?, Error> =
    Ok(entities[id])
  
  fun reset() = entities.clear()
}
```

### Service Integration

**Services consume DAOs:**
```kotlin
@BitkeyInject(AppScope::class)
class EntityServiceImpl(
  private val entityDao: EntityDao
) : EntityService {
  
  override suspend fun createEntity(request: CreateEntityRequest): Result<Entity, EntityError> {
    val entity = Entity(id = generateId(), name = request.name)
    return entityDao.insertEntity(entity)
      .map { entity }
      .mapError { EntityError.DatabaseError(it) }
  }
  
  override val entities: Flow<List<Entity>> = flow {
    entityDao.getAllEntities()
      .onSuccess { emit(it) }
      .onFailure { logFailure("Load failed", it) }
  }
}
```

### Error Handling

```kotlin
sealed interface EntityDaoError : Error {
  data class NotFound(val id: EntityId) : EntityDaoError
  data class DatabaseError(val cause: DbError) : EntityDaoError
}

override suspend fun getEntity(id: EntityId): Result<Entity, EntityDaoError> =
  databaseProvider.database()
    .entityQueries
    .getEntity(id)
    .awaitAsOneOrNullResult()
    .mapError { EntityDaoError.DatabaseError(it) }
    .flatMap { dbEntity ->
      dbEntity?.let { Ok(mapToEntity(it)) }
        ?: Err(EntityDaoError.NotFound(id))
    }
```

### Testing

```kotlin
class EntityDaoImplTest : FunSpec({
  val databaseProvider = BitkeyDatabaseProviderMock()
  val dao = EntityDaoImpl(databaseProvider)
  
  beforeTest { databaseProvider.reset() }
  
  test("inserts and retrieves entity") {
    val entity = createTestEntity()
    dao.insertEntity(entity).shouldBeOk()
    dao.getEntity(entity.id).shouldBeOk() shouldBe entity
  }
})

// Service tests use fake DAOs
class EntityServiceImplTest : FunSpec({
  val entityDao = EntityDaoFake()
  val service = EntityServiceImpl(entityDao)
  
  beforeTest { entityDao.reset() }
  
  test("creates entity successfully") {
    val result = service.createEntity(CreateEntityRequest("Test"))
    result.shouldBeOk().name shouldBe "Test"
  }
})
```

## Example

```kotlin
// CoachmarkDao from codebase
interface CoachmarkDao {
  suspend fun insertCoachmark(id: CoachmarkIdentifier, expiration: Instant): Result<Unit, Error>
  suspend fun setViewed(id: CoachmarkIdentifier): Result<Unit, Error>
  suspend fun getCoachmark(id: CoachmarkIdentifier): Result<Coachmark?, Error>
}

@BitkeyInject(AppScope::class)
class CoachmarkDaoImpl(
  private val databaseProvider: BitkeyDatabaseProvider,
) : CoachmarkDao {
  
  override suspend fun insertCoachmark(
    id: CoachmarkIdentifier,
    expiration: Instant,
  ): Result<Unit, DbError> =
    databaseProvider.database()
      .coachmarksQueries
      .awaitTransactionWithResult {
        createCoachmark(id = id, viewed = false, expiration = expiration)
      }
  
  override suspend fun getCoachmark(id: CoachmarkIdentifier): Result<Coachmark?, DbError> =
    databaseProvider.database()
      .coachmarksQueries
      .getCoachmark(id)
      .awaitAsOneOrNullResult()
      .map { it?.toCoachmark() }
}

// Service usage
class CoachmarkServiceImpl(
  private val coachmarkDao: CoachmarkDao,
) : CoachmarkService {
  
  override suspend fun markCoachmarkAsDisplayed(
    coachmarkId: CoachmarkIdentifier
  ): Result<Unit, Error> =
    coachmarkDao.setViewed(coachmarkId)
}
```

## Related Rules

- @ai-rules/domain-service-pattern.md (for service layer integration)
- @ai-rules/strong-typing.md (for domain entity types)
- @ai-rules/module-structure.md (for proper DAO placement in modules)
- @ai-rules/kmp-code-structure.md (for shared data access layer patterns)
