---
description: Factory pattern for runtime selection between implementations
alwaysApply: true
---

# Factory Pattern

## Summary

Factories provide interface implementations at runtime based on state (persisted, runtime, or external). They contain no business logic, only instance selection and construction. Many are misnamed as "Provider" which conflates them with domain components.

## When to Apply

- Providing implementations based on state (account config, platform, feature flags)
- Creating platform-specific implementations
- Renaming misnamed "Provider" components that are actually factories

## How to Apply

**Purpose**: Provide implementations at runtime - no domain logic or data fetching

**Method Naming**:
- `get()`: Returns potentially cached instance
- `create()`: Always constructs new instance
- `getOrCreate()`: Returns existing or creates if needed

**Parameters**: Minimize - only required construction parameters not available from state

```kotlin
// ✅ GOOD: Factory using persisted state
@BitkeyInject(AppScope::class)
class SocRecF8eClientProviderImpl(
  private val accountConfigService: AccountConfigService,
  @Fake private val socRecF8eClientFake: SocRecF8eClient,
  @Impl private val socRecF8eClientImpl: SocRecF8eClient,
) : SocRecF8eClientProvider {
  
  override fun get(): SocRecF8eClient {
    return if (accountConfigService.activeOrDefaultConfig().value.isUsingSocRecFakes) {
      socRecF8eClientFake
    } else {
      socRecF8eClientImpl
    }
  }
}

// ✅ GOOD: Factory using runtime parameter
class TreasuryWalletFactory(
  private val spendingWalletProvider: SpendingWalletProvider,
) {
  suspend fun create(networkType: BitcoinNetworkType): TreasuryWallet {
    return when (networkType) {
      REGTEST -> RegtestTreasuryWallet(...)
      SIGNET -> SignetTreasuryWallet(...)
    }
  }
}

// ❌ BAD: Provider mixing factory and domain logic
// CONSEQUENCES: Unclear responsibilities, difficult testing, violates single responsibility
class NotificationProvider(
  private val client: NotificationClient,
  private val dao: NotificationDao,
) {
  fun getNotifications(): List<Notification> {
    // Domain logic - should be in Service
    val data = client.fetch()
    dao.save(data)
    return data.map { transform(it) }
  }
  
  fun getClient(): NotificationClient {
    // Factory logic mixed with service
    return if (accountConfig.isFake) fakeClient else realClient
  }
}
```

## Example

**Providers Requiring Rename to Factory**: `BitkeyDatabaseProvider`, `FwupDataDaoProvider`, `SocRecF8eClientProvider`, `SpendingWalletProvider`, `CloudStoreServiceProvider`

**Providers That Are Not Factories**: `NotificationsPreferencesCachedProvider` (fetches data), `BiometricTextProvider` (platform text), `StringResourceProvider` (localized strings)

## Related Rules

- @ai-rules/domain-service-pattern.md (for Service pattern definition)
- @ai-rules/module-structure.md (for factory placement in modules)
