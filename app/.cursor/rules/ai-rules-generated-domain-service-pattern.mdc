---
description: Domain service pattern for encapsulating business logic and domain workflows
alwaysApply: true
---

# Domain Service Pattern

## Summary
Services encapsulate business logic and domain operations, replacing deprecated Data State Machine pattern. Provide clear separation between domain and presentation logic.

## When to Apply
- Implementing business logic coordinating multiple operations
- Creating domain operations orchestrating repositories, clients, services
- Separating business rules from UI presentation logic
- Replacing deprecated Data State Machine implementations

## How to Apply

### Service Definition
**Interface-first services:**
- Define in `:public` modules for cross-module use
- For internal-only: interface + implementation in `:impl` module
- Use domain-specific terminology
- Focus on what service accomplishes, not how

**Responsibilities:**
- Encapsulate business logic in bounded contexts
- Coordinate operations across repositories, clients, services
- Maintain internal state and integrity
- Expose domain operations through predictable APIs

### Consumer Rules
**Can consume services:**
- ✅ Presentation logic (UI State Machines, Presenters)
- ✅ Other Services (orchestration)
- ❌ Lower-level components (clients, repositories, DAOs)

**Data access:**
- Pull data directly from Services in presentation layer
- Never pass domain state through Screen constructors
- Avoid prop-drilling between State Machines

## Example
```kotlin
// ✅ GOOD: Simple, focused service interface
interface CoachmarkService {
  suspend fun coachmarksToDisplay(
    coachmarkIds: Set<CoachmarkIdentifier>
  ): Result<List<CoachmarkIdentifier>, Error>
  
  suspend fun markCoachmarkAsDisplayed(
    coachmarkId: CoachmarkIdentifier
  ): Result<Unit, Error>
}

// ✅ GOOD: Service implementation with clear dependencies
class CoachmarkServiceImpl(
  private val storage: CoachmarkStorage,
  private val policy: CoachmarkDisplayPolicy
) : CoachmarkService {
  override suspend fun coachmarksToDisplay(
    coachmarkIds: Set<CoachmarkIdentifier>
  ): Result<List<CoachmarkIdentifier>, Error> {
    // Business logic implementation
  }
}

// ❌ BAD: Mixing UI concerns with domain logic
interface PaymentService {
  suspend fun processPayment(request: PaymentRequest)
  fun getPaymentScreenState(): PaymentScreenState // UI concern in domain
  suspend fun showConfirmationDialog(): UserChoice // UI concern
}

// ❌ BAD: Repository depending on Service
class UserRepository(
  private val accountService: AccountService // Circular dependency
)
```

**Error handling:** Use generic `Error` in public APIs unless presentation needs domain-specific error types.

**Codebase examples:** `CoachmarkService` (simple), `TxVerificationService` (complex)

## Related Rules
- @ai-rules/strong-typing.md (service method parameters and return types)
- @ai-rules/module-structure.md (service placement in `:public` and `:impl`)
